Given a binary matrix mat[][] of size n * m. Find the maximum area of a rectangle formed only of 1s in the given matrix.

Examples:

Input: mat[][] = [[0, 1, 1, 0],
                [1, 1, 1, 1],
                [1, 1, 1, 1],
                [1, 1, 0, 0]]
Output: 8
Explanation: The largest rectangle with only 1’s is from (1, 0) to (2, 3) which is
[1, 1, 1, 1]
[1, 1, 1, 1]
and area is 4 *2 = 8.


JAVA CODE:

/*Complete the function given below*/
class Solution {
    // Returns area of the largest rectangle with all 1s in mat[][]
    static int maxArea(int mat[][]) {
        // Your code here
        int n = mat.length;
        int m = mat[0].length;
        
        int height[] = new int[m];
        for(int i = 0;i < m;i++){
            height[i] = mat[0][i];
        }
        
        int maxArea = Mah(height);
        for(int i = 1;i < n;i++){
            for(int j = 0;j < m;j++){
                if(mat[i][j] == 0 ){
                    height[j]  = 0;
                }else{
                    height[j]  += mat[i][j];
                }
            }
            maxArea = Math.max(maxArea,Mah(height));
        }
        return maxArea;
    }
    private static int Mah(int arr[]) {
        int n = arr.length;

        int[] left = nearestSmallerToLeft(arr, n);
        int[] right = nearestSmallerToRight(arr, n);

        int maxArea = 0;
        for (int i = 0; i < n; i++) {
            int width = right[i] - left[i] - 1;
            int area = arr[i] * width;
            maxArea = Math.max(maxArea, area);
        }
        return maxArea;
    }

    private static int[] nearestSmallerToLeft(int arr[], int n) {
        int[] left = new int[n];
        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
                stack.pop();
            }
            if (!stack.isEmpty()) {
                left[i] = stack.peek();
            } else {
                left[i] = -1;
            }
            stack.push(i);  // ✅ push index
        }
        return left;
    }

    private static int[] nearestSmallerToRight(int arr[], int n) {
        int[] right = new int[n];
        Stack<Integer> stack = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {
                stack.pop();
            }
            if (!stack.isEmpty()) {
                right[i] = stack.peek();
            } else {
                right[i] = n;  // ✅ use n instead of -1
            }
            stack.push(i);  // ✅ push index
        }
        return right;
    }
}
